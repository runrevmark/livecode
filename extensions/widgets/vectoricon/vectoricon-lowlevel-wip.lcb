/*
Copyright (C) 2015-2016 LiveCode Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

widget com.livecode.widget.vectoricon
--

-- dependency declarations
use com.livecode.canvas
use com.livecode.widget
use com.livecode.engine

-- A VGProgram is a list of lists where each element is list of the form:
--   [ <opcode>, <arglist> ]
type VGProgram is List
type VGOpcode is Integer

-- adding metadata to ensure the extension displays correctly in livecode
metadata title is "Vector Icon"
metadata author is "LiveCode"
metadata version is "0.0.0"

--

property vglText get GetVGLText set SetVGLText

--

variable currentProgram as VGProgram

--

handler OnPaint() returns nothing
end handler

handler GetVGLText() returns String
	return the empty string
end handler

handler SetVGLText(in pProgramString as String)
	variable tProgram as optional VGProgram
	variable tErrors as optional String
	put VGCompile(pProgramString, tProgram) into tErrors
	if tErrors is not nothing then
		throw tErrors
	end if

	put tProgram into currentProgram

	log "%@" with [ tProgram ]

	redraw all
end handler

--

-- B
constant kVGOpcodeBegin is 1
-- E
constant kVGOpcodeEnd is 2
-- T
constant kVGOpcodeTransform is 3
-- O
constant kVGOpcodeOpacity is 4

-- PM <x>, <y>
constant kVGOpcodePathMoveTo is 5
-- PM <x>, <y>
constant kVGOpcodePathLineTo is 6
-- PC <ax>, <ay>, <bx>, <by>, <cx>, <cy>
constant kVGOpcodePathCubicTo is 7
-- PQ <ax>, <ay>, <cx>, <cy>
constant kVGOpcodePathQuadTo is 8
-- PZ
constant kVGOpcodePathClose is 9

constant kVGOpcodeFillPaintNone is 10
-- FPS <red>, <green>, <blue>
constant kVGOpcodeFillPaintSolid is 11
-- FPL <x1>, <y1>, <x2>, <y2>, <count>, (<offset>, <red>, <green>, <blue>, <opacity>)*
constant kVGOpcodeFillPaintLinear is 12
-- FPR <cx>, <cy>, <r>, <count>, (<offset>, <red>, <green>, <blue>, <opacity>)*
constant kVGOpcodeFillPaintRadial is 13
-- FRNZ
constant kVGOpcodeFillRuleNonZero is 14
-- FREO
constant kVGOpcodeFillRuleEvenOdd is 15
-- FO
constant kVGOpcodeFillOpacity is 16

constant kVGOpcodeStrokePaintNone is 17
constant kVGOpcodeStrokePaintSolid is 18
constant kVGOpcodeStrokePaintLinear is 19
constant kVGOpcodeStrokePaintRadial is 20
constant kVGOpcodeStrokeWidth is 21
constant kVGOpcodeStrokeCapButt is 22
constant kVGOpcodeStrokeCapRound is 23
constant kVGOpcodeStrokeCapSquare is 24
constant kVGOpcodeStrokeJoinBevel is 25
constant kVGOpcodeStrokeJoinRound is 26
constant kVGOpcodeStrokeJoinMiter is 27
constant kVGOpcodeStrokeMiterLimit is 28
constant kVGOpcodeStrokeDashArray is 29
constant kVGOpcodeStrokeDashOffset is 30
constant kVGOpcodeStrokeOpacity is 31

constant kVGOpcodeNames is [ \
	"B", "E", "T", "O", \
	"PMT", "PLT", "PCT", "PQT", "PC", \
	"FPN", "FPS", "FPL", "FPR", "FRNZ", "FREO", "FO", \
	"SPN", "SPS", "SPL", "SPR", "SW", "SCB", "SCR", "SCS", "SJB", "SJR", "SJM", "SML", "SDA", "SDO", "SO" \
]

constant kVGOpcodeFormats is [ \
	0, 0, 6, 1, \
	2, 2, 6, 4, 0, \
	3, nothing, nothing, 0, 0, 1, \
	3, nothing, nothing, 1, 0, 0, 0, 0, 0, 0, 1, nothing, 1, 1 \
]

handler VGCompileParseCommand(in pCommand as String, out rOpcode as optional VGOpcode, out rArguments as optional List) returns optional String
	variable tNameEndOffset as Integer
	variable tName as String
	variable tArgumentStrings as List
	put the first offset of " " in pCommand into tNameEndOffset
	if tNameEndOffset is 0 then
		put pCommand into tName
		put the empty list into tArgumentStrings
	else
		put char 1 to tNameEndOffset - 1 of pCommand into tName
		split (char tNameEndOffset to the number of chars in pCommand of pCommand) by "," into tArgumentStrings
	end if

	variable tOpcode as VGOpcode
	put the first index of tName in kVGOpcodeNames into tOpcode
	if tOpcode is 0 then
		return "Unknown opcode name '" & tName & "'"
	end if

	variable tArguments as List
	variable tArgumentString as String
	repeat for each element tArgumentString in tArgumentStrings
		variable tArgument as optional Number
		put tArgumentString parsed as number into tArgument
		if tArgument is nothing then
			return "Invalid argument '" & tArgumentString & "'"
		end if
		push tArgument onto back of tArguments
	end repeat

	variable tFormat as optional Integer
	put kVGOpcodeFormats[tOpcode] into tFormat
	if tFormat is not nothing then
		if the number of elements in tArguments is not tFormat then
			return "Expected " & (tFormat formatted as string) & " arguments"
		end if
	else
		if tFormat is kVGOpcodeFillPaintLinear or \
			tFormat is kVGOpcodeStrokePaintLinear then
			if the number of elements in tArguments < 5 then
				return "Expected at least 5 arguments"
			end if

			variable tStopCount as Integer
			put the floor of tArguments[5] into tStopCount
			if tStopCount is not tArguments[5] then
				return "The fifth argument must be an integer"
			end if

			if the number of elements in tArguments is not 5 + tStopCount * 5 then
				return "Expected " & (5 + tStopCount * 5) formatted as string & " arguments"
			end if
		else if tFormat is kVGOpcodeFillPaintRadial or \
			tFormat is kVGOpcodeStrokePaintRadial then
			if the number of elements in tArguments < 5 then
				return "Expected at least 5 arguments"
			end if

			variable tStopCount as Integer
			put the floor of tArguments[4] into tStopCount
			if tStopCount is not tArguments[4] then
				return "The forth argument must be an integer"
			end if

			if the number of elements in tArguments is not 4 + tStopCount * 5 then
				return "Expected " & (4 + tStopCount * 5) formatted as string & " arguments"
			end if
		else if tFormat is kVGOpcodeStrokeDashArray then
			if the number of elements in tArguments < 1 then
				return "Expected at least 1 argument"
			end if

			variable tDashCount as Integer
			put the floor of tArguments[1] into tDashCount
			if tDashCount is not tArguments[1] then
				return "The first argument must be an integer"
			end if

			if the number of elements in tArguments is not 1 + tDashCount then
				return "Expected " & (1 + tDashCount) formatted as string & " arguments"
			end if
		else
			return "*** custom opcode layout not implemented ***"
		end if
	end if

	put tOpcode into rOpcode
	put tArguments into rArguments

	return nothing
end handler

-- The input format for VGCompile is a return-delimited string of operations
-- with syntax indicated by each opcode. e.g.
--   PMT 0, 0
--   PLT 0, 100
--   PLT 100, 100
--   PZ
handler VGCompile(in pString as String, out rProgram as optional VGProgram) returns optional String
	variable tErrors as List

	variable tCommandStrings as List
	split pString by "\n" into tCommandStrings

	variable tProgram as VGProgram

	variable tCommandString as String
	variable tCommandRow as Integer
	repeat for each element tCommandString in tCommandStrings
		add 1 to tCommandRow

		variable tOpcode as optional Integer
		variable tArguments as optional List
		variable tError as optional String
		put VGCompileParseCommand(tCommandString, tOpcode, tArguments) into tError
		if tError is not nothing then
			push "error, row " & (tCommandRow formatted as string) & ": " & tError onto back of tErrors
		end if

		push [ tOpcode, tArguments ] onto back of tProgram
	end repeat

	if tErrors is not the empty list then
		put nothing into rProgram

		variable tErrorsString
		combine tErrors with "\n" into tErrorsString
		return tErrorsString
	end if

	put tProgram into rProgram

	return nothing
end handler

handler VGExecute(in pProgram as VGProgram, in pCanvas as Canvas)
	variable tCommand as List
	repeat for each element tCommand in pProgram
		variable tOpcode as Integer
		variable tArguments as List
		put tCommand[1] into tOpcode
		put tCommand[2] into tArguments

		if tOpcode is kVGOpcodeBegin then
			begin layer on pCanvas
		else if tOpcode is kVGOpcodeEnd then
			end layer on pCanvas
		else if tOpcode is kVGOpcodeTransform then
			transform pCanvas by transform with matrix tArguments
		else if tOpcode is kVGOpcodeOpacity then
			set the opacity of pCanvas to tArguments[1]
		else if tOpcode is kVGOpcodePathMoveTo then
			move to point tArguments on pCanvas
		else if tOpcode is kVGOpcodePathLineTo then
			line to point tArguments on pCanvas
		else if tOpcode is kVGOpcodePathCubicTo then
			curve through (element 1 to 2 of tArguments) then \
					(element 3 to 4 of tArguments) to \
					(element 5 to 6 of tArguments) on pCanvas
		else if tOpcode is kVGOpcodePathQuadTo then
			curve through (element 1 to 2 of tArguments) to \
					(element 3 to 4 of tArguments) on pCanvas
		else if tOpcode is kVGOpcodePathClose then
			close path on canvas pCanvas
		else if tOpcode is kVGOpcodeFillPaintNone then
		else if tOpcode is kVGOpcodeFillPaintSolid then
		else if tOpcode is kVGOpcodeFillPaintLinear then
		else if tOpcode is kVGOpcodeFillPaintRadial then
		else if tOpcode is kVGOpcodeFillRuleNonZero then
		else if tOpcode is kVGOpcodeFillRuleEvenOdd then
		else if tOpcode is kVGOpcodeFillOpacity then
		else if tOpcode is kVGOpcodeStrokePaintNone then
		else if tOpcode is kVGOpcodeStrokePaintSolid then
		else if tOpcode is kVGOpcodeStrokePaintLinear then
		else if tOpcode is kVGOpcodeStrokePaintRadial then
		else if tOpcode is kVGOpcodeStrokeWidth then
		else if tOpcode is kVGOpcodeStrokeCapButt then
		else if tOpcode is kVGOpcodeStrokeCapRound then
		else if tOpcode is kVGOpcodeStrokeCapSquare then
		else if tOpcode is kVGOpcodeStrokeJoinBevel then
		else if tOpcode is kVGOpcodeStrokeJoinRound then
		else if tOpcode is kVGOpcodeStrokeJoinMiter then
		else if tOpcode is kVGOpcodeStrokeMiterLimit then
		else if tOpcode is kVGOpcodeStrokeDashArray then
		else if tOpcode is kVGOpcodeStrokeDashOffset then
		else if tOpcode is kVGOpcodeStrokeOpacity then
		end if
	end repeat
end handler


end widget
